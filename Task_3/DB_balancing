function sysCall_init()
    corout=coroutine.create(coroutineMain)
end

function sysCall_actuation()
    if coroutine.status(corout)~='dead' then
        local ok,errorMsg=coroutine.resume(corout)
        if errorMsg then
            error(debug.traceback(corout,errorMsg),2)
        end
    end
end

function sysCall_cleanup()
    -- do some clean-up here
end

-- Function to Multiply Matrices:
function MatMul(m1, m2)
    if #m1[1] ~= #m2 then       -- inner matrix-dimensions must agree
        return nil      
    end 
 
    local res = {}
 
    for i = 1, #m1 do
        res[i] = {}
        for j = 1, #m2[1] do
            res[i][j] = 0
            for k = 1, #m2 do
                res[i][j] = res[i][j] + m1[i][k] * m2[k][j]
            end
        end
    end
 
    return res
end

-- Function to Subtract Vectors:
function Subtract(m1, m2)
    if #m1 ~= #m2 or #m1[1] ~= #m2[1] then       -- inner matrix-dimensions must agree
        return nil      
    end 
 
    local res = {}
 
    for i = 1, #m1 do
        res[i] = {}
        for j = 1, #m2[1] do
            res[i][j] = m1[i][j] - m2[i][j]
        end
    end
 
    return res
end

function coroutineMain()
    -- Put some initialization code here
    
    -- Object Handles:
    Chassis = sim.getObjectHandle("DairyBikeChassis")
    Rear_wheel = sim.getObjectHandle("RearWheel_Respondable")
    Front_wheel = sim.getObjectHandle("FrontWheel_Respondable")
    Reaction_wheel = sim.getObjectHandle("ReactionWheel")
    Front_susp = sim.getObjectHandle("Front_susp")
    -- Manipulator = sim.getObjectHandle("Manipulator_base")
    ReactionWheelMotor = sim.getObjectHandle("ReactionWheelMotor")
    pivot_pt = sim.getObjectHandle("pivot_pt")
    
    RW_pos_wrt_origin = sim.getObjectPosition(Reaction_wheel, -1)
    pivot_pos_wrt_origin = sim.getObjectPosition(pivot_pt, -1)
    
    -- Find out the constants:
    m1 = sim.getShapeMass(Chassis) -- Mass of pole
    m2 = sim.getShapeMass(Reaction_wheel) -- Mass of Reaction wheel
    -- Get Required Object Parameters:
    _, _, RW_geom = sim.getShapeGeomInfo(Reaction_wheel)
    _, _, Pole_geom = sim.getShapeGeomInfo(Chassis)
    wr = RW_geom[1]/2 -- Radius of Reaction Wheel
    l1 = math.sqrt((RW_pos_wrt_origin[1] - pivot_pos_wrt_origin[1])^2 + (RW_pos_wrt_origin[2] - pivot_pos_wrt_origin[2])^2 + (RW_pos_wrt_origin[3] - pivot_pos_wrt_origin[3])^2) -- Length of Reaction Wheel
    g = 9.81 -- gravity constant
    I = 0.5*m2*wr*wr -- Moment of inertia of Reaction Wheel
    -- K = {{-490.9853, -82.1830, 4.4721, 11.9591}}
    -- K = {{-1399.952657, -315.595907, 0.014142, 1.390643}}
    K = {{-1399.952657, -315.595907, 0.014142, 1.390643}}
    -- R = 0.002
    -- R = 0.00579
    -- R = 0.0016  -- Max torque 17Nm falls in 7 secs
    -- R = 0.0017     -- Max torque 18Nm falls in 9 secs
    -- R = 0.0018    -- Max torque 19.6Nm falls in > 20 secs
    R = 0.03
    
    target = {{math.pi}, {0}, {2*math.pi}, {0}}
        
    del_t = sim.getSimulationTimeStep()
    
    time_prev = 0
    
    
    pivot_pt_orientation = sim.getObjectOrientation(pivot_pt, -1)

    Mx = RW_pos_wrt_origin[1]
    Px = pivot_pos_wrt_origin[1]
    My = RW_pos_wrt_origin[2]
    Py = pivot_pos_wrt_origin[2]
    Mz = RW_pos_wrt_origin[3] 
    Pz = pivot_pos_wrt_origin[3]

    -- print(pivot_pt_orientation[3])
    
    -- In direction of -Y
    if pivot_pt_orientation[3] < 0.78 and pivot_pt_orientation[3] > -0.78 then
        if Mx > Px then
            x1_prev = math.pi - math.acos((Mz - Pz)/l1)
        else
            x1_prev = math.pi + math.acos((Mz - Pz)/l1)
        end
    end

    -- In direction of Y
    if pivot_pt_orientation[3] < -2.35 and pivot_pt_orientation[3] > 2.35 then
    print("In")
        if Mx > Px then
            x1_prev = math.pi + math.acos((Mz - Pz)/l1)
        else
            x1_prev = math.pi - math.acos((Mz - Pz)/l1)
        end
    end
   
    -- In direction of -X
    if pivot_pt_orientation[3] > -2.35 and pivot_pt_orientation[3] < -0.78 then
        if My > Py then
            x1_prev = math.pi + math.acos((Mz - Pz)/l1)
        else
            x1_prev = math.pi - math.acos((Mz - Pz)/l1)
        end
    end
    
    -- In direction of X
    if pivot_pt_orientation[3] < 2.35 and pivot_pt_orientation[3] > 0.78 then
        if My > Py then
            x1_prev = math.pi - math.acos((Mz - Pz)/l1)
        else
            x1_prev = math.pi + math.acos((Mz - Pz)/l1)
        end
    end
    
    a = 0
    
    while true do
        
        -- X1(Angular position of Pivot) with ref plane out of heirarchy
        
        --print(RW_pos_wrt_origin)
        --print(pivot_pos_wrt_origin)
        
        pivot_pt_orientation = sim.getObjectOrientation(pivot_pt, -1)
        -- print(pivot_pt_orientation[3])    
        
        RW_pos_wrt_origin = sim.getObjectPosition(Reaction_wheel, -1)
        pivot_pos_wrt_origin = sim.getObjectPosition(pivot_pt, -1)
       
        Mx = RW_pos_wrt_origin[1]
        Px = pivot_pos_wrt_origin[1]
        My = RW_pos_wrt_origin[2]
        Py = pivot_pos_wrt_origin[2]
        Mz = RW_pos_wrt_origin[3] - pivot_pos_wrt_origin[3]
        Pz = pivot_pos_wrt_origin[3]
    
    -- In direction of -Y
    if pivot_pt_orientation[3] < 0.78 and pivot_pt_orientation[3] > -0.78 then
        if Mx > Px then
            x1 = math.pi - math.acos((Mz - Pz)/l1)
        else
            x1 = math.pi + math.acos((Mz - Pz)/l1)
        end
    end

    -- In direction of Y
    if pivot_pt_orientation[3] < -2.35 and pivot_pt_orientation[3] > 2.35 then
        if Mx > Px then
            x1 = math.pi + math.acos((Mz - Pz)/l1)
        else
            x1 = math.pi - math.acos((Mz - Pz)/l1)
        end
    end
   
    -- In direction of -X
    if pivot_pt_orientation[3] > -2.35 and pivot_pt_orientation[3] < -0.78 then
        if My > Py then
            x1 = math.pi + math.acos((Mz - Pz)/l1)
        else
            x1 = math.pi - math.acos((Mz - Pz)/l1)
        end
    end
    
    -- In direction of X
    if pivot_pt_orientation[3] < 2.35 and pivot_pt_orientation[3] > 0.78 then
        if My > Py then
            x1 = math.pi - math.acos((Mz - Pz)/l1)
        else
            x1 = math.pi + math.acos((Mz - Pz)/l1)
        end
    end
        
    -- print(x1)
        
        time_now = sim.getSimulationTime()
        
        x2 = (x1 - x1_prev)/(time_now - time_prev)
        
        if time_now ~= time_prev and x1 ~= x1_prev then
            flag = 1
            x1_prev = x1
            -- print("X2 = ", x2)
            time_prev = time_now
        else
            flag = 0
        end
        
        x3 = sim.getJointPosition(ReactionWheelMotor)
        -- print(x3)
        x4 = sim.getJointVelocity(ReactionWheelMotor)
        -- print(x4)
        
        -- Define State Matrix:
        X = {{x1}, {x2}, {x3}, {x4}}
        
        -- Calculate Torque required through feedback:
        if flag == 1 then
            error = Subtract(X, target)
            -- print(error)
            u = -MatMul(K, error)[1][1]
            u = u*R
            -- Calculate Target Velocity:
            acc = u/I
            vel = acc*del_t - x4
        end        
        
        -- Actuate the Joint by changing max force and calculating the next velocity:
        
        if flag == 1 then
                print(u, x1*180/math.pi)
                sim.setJointMaxForce(ReactionWheelMotor, math.abs(u))
                sim.setJointTargetVelocity(ReactionWheelMotor, (u/math.abs(u))*(1000))
        end
    end
end

-- See the user manual or the available code snippets for additional callback functions and details
